[{"path":"https://jrjordanrh.github.io/UWBiost561/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 UWBiost561 authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW1.html","id":"instructions","dir":"Articles","previous_headings":"","what":"Instructions","title":"BIOST 561: Homework 1","text":"instructions essential, please read carefully. Submit homework RMarkdown (.Rmd) file HTML file GitHub page. (later, first homework guide .) Please answer question prompt show code (inline). , code visible knitted chunks. complete homework, may write HW1.Rmd file. (recommended complete homework R Studio, clicking Knit button knit homework.)","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW1.html","id":"disclosures","dir":"Articles","previous_headings":"","what":"Disclosures","title":"BIOST 561: Homework 1","text":"Please disclose collaborated ’ve used ChatGPT (comparable AI tool) extent completing homework. See syllabus course expectations.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW1.html","id":"q0-survey","dir":"Articles","previous_headings":"","what":"Q0: Survey","title":"BIOST 561: Homework 1","text":"Intent: question simply course logistics course instructor get know . Question 0A: Please let know preferred name preferred pronouns. Jordan Rodriguez, /Question 0B: Please read syllabus entirety write, “read understood entire syllabus,” question. questions syllabus (example, homework submission policy collaboration policy), may ask . read understood enitre syllabus Question 0C: , please briefly describe courses taken UW involve coding (language) far familiar/comfortable coding R. (Note: expect taken courses already.) fell familiar R Question 0D: hope learn course? (alright leave blank, helpful hear thoughts.) ’m eager learn software-engineering perspective automate processes.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW1.html","id":"q1-setting-up-an-r-package-and-github","dir":"Articles","previous_headings":"","what":"Q1: Setting up an R package and GitHub","title":"BIOST 561: Homework 1","text":"Intent: section question guide step--step make R package GitHub, critical course. question challenging students familiar R Studio GitHub, please ask instructor questions. Please read walk https://docs.google.com/document/d/1sB5qwkeOWnCU-UUkHxOjqUTep0kgpvUi7qtHo7eV8oU/edit?usp=sharing, mentioned class. Upon completion walkthrough, get full marks question, : Created GitHub account, Created private GitHub repository called UWBiost561, Created R package, located GitHub repository UWBiost561, Created vignette, includes HW1.Rmd HW1.html vignettes folder, GitHub repository UWBiost561, Added username linnykos Collaborator GitHub repository UWBiost561. Note: lot familiarity R Studio GitHub, question quite challenging (even though ’re following walkthrough). Please start early feel nervous instructor (Kevin) can better help give ample time come office hours. (need write anything question.)","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW1.html","id":"q2-simulating-the-central-limit-theorem","dir":"Articles","previous_headings":"","what":"Q2: Simulating the Central Limit Theorem","title":"BIOST 561: Homework 1","text":"Intent: question simple coding exercise demonstrate familiarity basic coding R. Load generate_data function using following code (one line). code sources generate_data function current R workspace. Question 2A: Read function (either URL provided typing generate_data console), one three sentences, describe input output provided function function . may use equations needed. function accepts positive integer n input returns numeric vector length nn. First, generates index vector (idx_vec) randomly sampling n digits 1 3 replacement. , digit idx_vec, draws corresponding random sample specific distribution: normal distribution N(10,1) 1, gamma distribution 2, chi-square distribution 3. Finally, function stores random values positions output vector (sample_vec) correspond associated digit idx_vec. Question 2B: now using generate_data function. Observe run following code, compute (random, empirical) mean dataset n=10 samples: Repeat code 10,000 times (.e., 10,000 trials, keeping n=10 trial), plot histogram 10,000 different empirical means 100 breaks (.e., breaks = 100). Repeat process n values 1, 2, 3, 5, 100, plot six histograms order increasing n. Figure @ref(fig:clt) shows desired plot aim reproduce. particular, reproduce X- Y-labels, title plot, plot layout. (Hint: might find par function useful, especially mar mfrow arguments, well paste function. See documentation par.) figure trying reproduce (without Sample watermark) Question 2B, barring dimensions/proportions figure randomness inherent simulation. Question 2C: one three sentences, write plot reproduced helps verify Central Limit Theorem. increase sample size, distribution sample mean converges normal distribution","code":"source(\"https://raw.githubusercontent.com/linnykos/561_s2025_public/main/HW1_files/generate_data.R\") set.seed(1) mean(generate_data(n=10)) #> [1] 5.199818 library(ggplot2) results_ = matrix(NA,10000*6,2) n_ = c(1,2,3,5,10,100) results_[,1] = rep(n_, each = 10000) colnames(results_) = c(\"n\",\"value\")  for (k in 1:6){   for (i in 1:10000){     set.seed(i)     row_index = (k - 1) * 10000 + i     results_[row_index, 2] = mean(generate_data(n = n_[k]))   } }  dat1 = as.data.frame(results_) ggplot(dat1, aes(x = value)) +   geom_histogram(bins = 100, fill = \"steelblue\", color = \"white\") +   facet_wrap(~ n, scales = \"free_y\") +   theme_minimal() +   labs(title = \"Distributions of Sample Means\",        x = \"Sample Mean\",        y = \"Count\")"},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW1.html","id":"q3-basic-data-analysis","dir":"Articles","previous_headings":"","what":"Q3: Basic data analysis","title":"BIOST 561: Homework 1","text":"Intent: question simple data analysis demonstrate familiarity perform basic operations R. question, ’ll load simple dataset related Alzheimer’s Disease (AD) research. data originates single-cell database study. However, since first homework, ’ll mainly work donor-level data instead cell-level data. brief descriptions variable: Donor.ID: anonymized ID donor donated brain AD research Age..Death: age donor passed away Sex: biological sex donor. (Kevin’s comment: study, seems like strictly Male Female…?) APOE4.Status: Y (yes) N () donor particular genetic variant known risk factor AD Cognitive.Status: Whether donor dementia based wide array cognitive assessments death Last.CASI.Score: last score donor , measured via CASI (specific set cognitive questions), death Braak: Different severities neuropathology based donor’s brain tissue, extracted donor’s consent death Hopefully, reminder carefully describe study variables dataset publish collaborate ! Question 3A: Describe, two four sentences, head(df) summary(df) results display. prints first 6 observations allong variable names Question 3B: Use simple function print dimensionality df (.e., many rows columns ). class df? 84 observations 7 variables. class data frame Question 3C: ’ll note summary(df), variable Age..Death character, even though numeric. values 90+. simple diagnostic, 1) replace 90+ values df$Age..Death 90, 2) convert df$Age..Death character numeric, 3) plot histogram df$Age..Death. Figure @ref(fig:hist) shows desired plot aim reproduce.  figure trying reproduce (without Sample watermark) Question 3C, barring dimensions/proportions figure . Question 3D: summary() function much useful columns df factors, characters. Write lines code convert variables Sex, APOE4.Status, Cognitive.Status, Braak factors. (take less 10 lines code.) Question 3E: new version df, finishing previous questions, show result summary(df). Figure @ref(fig:summary) shows desired output aim reproduce. intended output Question 3E. one sentence, describe summary (Question 3E) informative summary shown start Question 3. provides many observations per level factor variables distribution numeric variables Question 3F: Using table() function, display relation Braak Cognitive.Status. Please look ?table (documentation table()) unfamiliar function. Question 3G: question slightly challenging. table() function useful many unique values (Last.CASI.Score). overcome , look documentation cut quantile functions. goal use table(), cut(), quantile() show relation quantiles Last.CASI.Score Cognitive.Status. want use na.rm=TRUE using quantile() function. Figure @ref(fig:table) shows desired output aim reproduce. intended output Question 3G. one two sentences, describe can learn relation Last.CASI.Score Cognitive.Status based result. lower score, higher risk dementia","code":"df <- read.csv(\"https://raw.githubusercontent.com/linnykos/561_s2025_public/main/HW1_files/sea-ad.csv\")  head(df) #>     Donor.ID Age.at.Death    Sex APOE4.Status Cognitive.Status Last.CASI.Score #> 1 H19.33.004           80 Female            N      No dementia              85 #> 2 H20.33.001           82   Male            N      No dementia              97 #> 3 H20.33.002          90+ Female            N      No dementia              93 #> 4 H20.33.004           86   Male            Y         Dementia              80 #> 5 H20.33.005          90+ Female            N      No dementia              94 #> 6 H20.33.008          90+ Female            Y      No dementia              92 #>      Braak #> 1 Braak IV #> 2 Braak IV #> 3 Braak IV #> 4  Braak V #> 5 Braak IV #> 6  Braak V  summary(df) #>    Donor.ID         Age.at.Death           Sex            APOE4.Status       #>  Length:84          Length:84          Length:84          Length:84          #>  Class :character   Class :character   Class :character   Class :character   #>  Mode  :character   Mode  :character   Mode  :character   Mode  :character   #>                                                                              #>                                                                              #>                                                                              #>                                                                              #>  Cognitive.Status   Last.CASI.Score    Braak           #>  Length:84          Min.   :66.00   Length:84          #>  Class :character   1st Qu.:80.00   Class :character   #>  Mode  :character   Median :89.00   Mode  :character   #>                     Mean   :87.32                      #>                     3rd Qu.:95.00                      #>                     Max.   :99.00                      #>                     NA's   :15 table(df$Age.at.Death) #>  #>  65  68  69  70  72  75  77  78  80  81  82  83  84  85  86  87  88  89 90+  #>   1   1   1   1   1   2   1   1   2   3   4   3   2   2   3   2   5   3  46  df$Age.at.Death = as.numeric(substr(df$Age.at.Death,1,2))  hist(df$Age.at.Death ) names(df) #> [1] \"Donor.ID\"         \"Age.at.Death\"     \"Sex\"              \"APOE4.Status\"     #> [5] \"Cognitive.Status\" \"Last.CASI.Score\"  \"Braak\"  df[,3:5] = lapply(df[,3:5], as.factor) summary(df) #>    Donor.ID          Age.at.Death       Sex     APOE4.Status #>  Length:84          Min.   :65.00   Female:51   N:59         #>  Class :character   1st Qu.:83.75   Male  :33   Y:25         #>  Mode  :character   Median :90.00                            #>                     Mean   :86.26                            #>                     3rd Qu.:90.00                            #>                     Max.   :90.00                            #>                                                              #>     Cognitive.Status Last.CASI.Score    Braak           #>  Dementia   :42      Min.   :66.00   Length:84          #>  No dementia:42      1st Qu.:80.00   Class :character   #>                      Median :89.00   Mode  :character   #>                      Mean   :87.32                      #>                      3rd Qu.:95.00                      #>                      Max.   :99.00                      #>                      NA's   :15 table(df$Braak, df$Cognitive.Status) #>             #>             Dementia No dementia #>   Braak 0          0           2 #>   Braak II         2           2 #>   Braak III        2           4 #>   Braak IV         4          19 #>   Braak V         20          14 #>   Braak VI        14           1 quantiles <- quantile(df$Last.CASI.Score, probs = seq(0, 1, 0.25), na.rm = TRUE) casi_quantile_group <- cut(df$Last.CASI.Score, breaks = quantiles, include.lowest = TRUE) table(casi_quantile_group, df$Cognitive.Status) #>                     #> casi_quantile_group Dementia No dementia #>             [66,80]       17           1 #>             (80,89]       10           8 #>             (89,95]        2          15 #>             (95,99]        3          13"},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW1.html","id":"q4-pushing-the-homework-onto-github","dir":"Articles","previous_headings":"","what":"Q4: Pushing the homework onto GitHub","title":"BIOST 561: Homework 1","text":"Intent: section question guide submitting homework. procedure expectation future homeworks. Now completed homework, ’s remaining push homework onto UWBiost561 GitHub repository. , please ensure: file named HW1.Rmd. (current homework file writing replace initial HW1.Rmd made completed walkthrough Question 1.) file vignettes folder UWBiost561 R package. push two files, HW1.Rmd HW1.html (latter knitted HTML file) onto GitHub repository. Double-check can see files online github.com look repository. LASTLY: Upload HW1.html Canvas “Assignment 1”. (university-wide policy, also helps keep track completion status homeworks via Canvas.) , ensure username linnykos added private GitHub repository. , ’re done! (future homeworks, “submitting” homeworks like .) (need write anything question.)","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW1.html","id":"q5-feedback-optional","dir":"Articles","previous_headings":"","what":"Q5: Feedback (Optional)","title":"BIOST 561: Homework 1","text":"“question” additional way students communicate instructors. include positive feedback topics enjoyed learning module, critiques course difficulty/pacing, questions/confusions course material. feedback can help us shape course rest quarter future years. Please mindful polite providing feedback. may leave question blank. Despite multi-step process, liked clear instructions. experience using github desktop windows using R sudio directly! interesting. Also appreciate data analysis section minimal.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW2.html","id":"instructions","dir":"Articles","previous_headings":"","what":"Instructions","title":"BIOST 561: Homework 2","text":"instructions essential, please read carefully. Submit homework GitHub page RMarkdown (.Rmd) HTML files. Please answer question prompt show code (inline). , code visible knitted chunks. complete homework, may write HW2.Rmd file. (recommended complete homework R Studio, clicking Knit button knit homework.)","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW2.html","id":"disclosures","dir":"Articles","previous_headings":"","what":"Disclosures","title":"BIOST 561: Homework 2","text":"Please disclose collaborated ’ve used ChatGPT (comparable AI tool) extent completing homework. See syllabus course expectations. used chatgpt modify ggplot code help read functions . (Hint: feel stuck homework, feel free consult ChatGPT. Often, need double-check responses ChatGPT verify correctness. advise ask ChatGPT generate minimal examples demonstrate use various functions, provide clear example function works.)","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW2.html","id":"q0-setting-up-your-uwbiost561-package","dir":"Articles","previous_headings":"","what":"Q0: Setting up your UWBiost561 package","title":"BIOST 561: Homework 2","text":"need write anything part question. Question 0A: Install tidyverse. (involve typing install.packages(\"tidyverse\") R console. need put Markdown file.) Question 0B: Update DESCRIPTION R package. , file called DESCRIPTION UWBiost561 package. look something like : Add following lines DESCRIPTION include bookdown, tidyverse, ggplot2. look like something like: Save file close . Question 0C: Make sure can load package. (need bookdown package knit homework, similar HW1.) (might throw warning “conflicted package.” can ignore .) Question 0D: Double check following things R package: HW1.html, HW1.Rmd, HW2.Rmd (file), --created HW2.html files vignettes folder R package. .gitignore file vignettes folder. (Please delete .gitignore file one exists.)","code":"Suggests:    knitr,   rmarkdown Suggests:    knitr,   rmarkdown,   bookdown,   tidyverse,   ggplot2 library(bookdown) library(tidyverse) #> ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ── #> ✔ dplyr     1.1.4     ✔ readr     2.1.5 #> ✔ forcats   1.0.0     ✔ stringr   1.5.1 #> ✔ ggplot2   3.5.2     ✔ tibble    3.3.0 #> ✔ lubridate 1.9.4     ✔ tidyr     1.3.1 #> ✔ purrr     1.0.4      #> ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── #> ✖ dplyr::filter() masks stats::filter() #> ✖ dplyr::lag()    masks stats::lag() #> ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors library(ggplot2)"},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW2.html","id":"q1-practice-using-tibbles","dir":"Articles","previous_headings":"","what":"Q1: Practice using tibbles","title":"BIOST 561: Homework 2","text":"Intent: question give basic practice using tibbles (tidyverse way analyzing data, overall). question, ’ll using two datasets collect various statistics countries many years. first dataset gt package (see https://search.r-project.org/CRAN/refmans/gt/html/countrypops.html), formatted specifically homework. can loaded following code: (Note ’re reading data using readr::read_csv function, automatically converts csv data tibble. read.csv function. See ?readr::read_csv ?read.csv.) country_population contains following columns: iso3c: Three-letter country code (see https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country: Country name year: Year statistic collected population: Population, based World Bank estimate next dataset https://paldhous.github.io/NICAR/2017/r-analysis.html, also formatted specifically homework. can loaded following code: country_birth contains following columns: iso2c: Two-letter country code iso3c: Three-letter country code year: Year statistic collected life_expect: Life expectancy birth, years. birth_rate: Live births year per 1,000 people neonat_mortal_rate: Neonatal mortality rate: babies dying reaching 28 days age per 1,000 live births given year question allow practice basic data manipulation two tibble objects. Question 1A: manipulating country_population data question. goal following: Select rows years 1990 2010 (inclusive). , compute mean population across years country country (defining new variable called mean_population, via group_by() summarize() functions). Figure @ref(fig:population) shows first two rows desired output. output trying reproduce (without Sample watermark) Question 1A. Question 1B: manipulating country_birth data question. goal following: Select rows years 1990 2010 (inclusive), keep iso3c, year, life_expect columns, drop rows NA 3 columns. , compute minimum maximum life expectancy (named new columns called min_life_expect max_life_expect) country across years (via summarize() function), finally, create new column called range_life_expect number years min_life_expect max_life_expect country (via mutate() function). Figure @ref(fig:birth) shows first two rows desired output. output trying reproduce (without Sample watermark) Question 1B. Question 1C: now combine country_population country_birth via join. Specifically, using inner_join() function, combine datasets iso3c variable, call new tibble object country_both. Print first 10 rows country_both. many rows columns country_both?","code":"country_population <- readr::read_csv(\"https://raw.githubusercontent.com/linnykos/561_s2025_public/main/HW2_files/country_population.csv\") #> Rows: 13545 Columns: 4 #> ── Column specification ──────────────────────────────────────────────────────── #> Delimiter: \",\" #> chr (2): iso3c, country #> dbl (2): year, population #>  #> ℹ Use `spec()` to retrieve the full column specification for this data. #> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. country_population #> # A tibble: 13,545 × 4 #>    iso3c country  year population #>    <chr> <chr>   <dbl>      <dbl> #>  1 ABW   Aruba    1960      54608 #>  2 ABW   Aruba    1961      55811 #>  3 ABW   Aruba    1962      56682 #>  4 ABW   Aruba    1963      57475 #>  5 ABW   Aruba    1964      58178 #>  6 ABW   Aruba    1965      58782 #>  7 ABW   Aruba    1966      59291 #>  8 ABW   Aruba    1967      59522 #>  9 ABW   Aruba    1968      59471 #> 10 ABW   Aruba    1969      59330 #> # ℹ 13,535 more rows country_birth <- readr::read_csv(\"https://raw.githubusercontent.com/linnykos/561_s2025_public/main/HW2_files/country_birth.csv\") #> Rows: 5486 Columns: 5 #> ── Column specification ──────────────────────────────────────────────────────── #> Delimiter: \",\" #> chr (1): iso3c #> dbl (4): year, life_expect, birth_rate, neonat_mortal_rate #>  #> ℹ Use `spec()` to retrieve the full column specification for this data. #> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. country_birth #> # A tibble: 5,486 × 5 #>    iso3c  year life_expect birth_rate neonat_mortal_rate #>    <chr> <dbl>       <dbl>      <dbl>              <dbl> #>  1 AND    1994          NA       10.9                3.2 #>  2 AND    1995          NA       11                  3   #>  3 AND    2006          NA       10.6                1.9 #>  4 AND    2007          NA       10.1                1.8 #>  5 AND    1996          NA       10.9                2.8 #>  6 AND    1993          NA       11.4                3.4 #>  7 AND    1997          NA       11.2                2.6 #>  8 AND    1998          NA       11.9                2.4 #>  9 AND    2008          NA       10.4                1.8 #> 10 AND    2009          NA        9.9                1.7 #> # ℹ 5,476 more rows pop1 = filter(country_population, year %in% c(1990:2010)) %>%    group_by(iso3c,country) %>%    summarize(     mean_population = mean(population, na.rm = T)   ) #> `summarise()` has grouped output by 'iso3c'. You can override using the #> `.groups` argument. pop1 #> # A tibble: 215 × 3 #> # Groups:   iso3c [215] #>    iso3c country              mean_population #>    <chr> <chr>                          <dbl> #>  1 ABW   Aruba                         85839. #>  2 AFG   Afghanistan                19819866. #>  3 AGO   Angola                     16829911. #>  4 ALB   Albania                     3095489. #>  5 AND   Andorra                       67825. #>  6 ARE   United Arab Emirates        3858774. #>  7 ARG   Argentina                  36972314. #>  8 ARM   Armenia                     3211816. #>  9 ASM   American Samoa                54995. #> 10 ATG   Antigua and Barbuda           74385. #> # ℹ 205 more rows birth1 = filter(country_birth, year %in% c(1990:2010)) %>%    select(iso3c, year, life_expect) %>%    filter(!is.na(iso3c),!is.na(year),!is.na(life_expect)) %>%    group_by(iso3c) %>%    summarize(     min_life_expect = min(life_expect),     max_life_expect = max(life_expect)   ) %>%    mutate(     range_life_expect = max_life_expect - min_life_expect   ) birth1 #> # A tibble: 203 × 4 #>    iso3c min_life_expect max_life_expect range_life_expect #>    <chr>           <dbl>           <dbl>             <dbl> #>  1 ABW              73.4            75.0              1.56 #>  2 AFG              49.9            59.0              9.11 #>  3 AGO              41.1            50.7              9.52 #>  4 ALB              71.9            77.0              5.14 #>  5 ARE              71.7            76.7              4.96 #>  6 ARG              71.5            75.5              3.94 #>  7 ARM              67.7            74.2              6.49 #>  8 ATG              71.2            75.3              4.15 #>  9 AUS              77.0            81.7              4.70 #> 10 AUT              75.6            80.6              5.01 #> # ℹ 193 more rows country_both = inner_join(pop1, birth1, by = \"iso3c\") country_both #> # A tibble: 202 × 6 #> # Groups:   iso3c [202] #>    iso3c country              mean_population min_life_expect max_life_expect #>    <chr> <chr>                          <dbl>           <dbl>           <dbl> #>  1 ABW   Aruba                         85839.            73.4            75.0 #>  2 AFG   Afghanistan                19819866.            49.9            59.0 #>  3 AGO   Angola                     16829911.            41.1            50.7 #>  4 ALB   Albania                     3095489.            71.9            77.0 #>  5 ARE   United Arab Emirates        3858774.            71.7            76.7 #>  6 ARG   Argentina                  36972314.            71.5            75.5 #>  7 ARM   Armenia                     3211816.            67.7            74.2 #>  8 ATG   Antigua and Barbuda           74385.            71.2            75.3 #>  9 AUS   Australia                  19200991.            77.0            81.7 #> 10 AUT   Austria                     8057573.            75.6            80.6 #> # ℹ 192 more rows #> # ℹ 1 more variable: range_life_expect <dbl>"},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW2.html","id":"q2-practice-using-ggplot-via-scatterplots-and-facets","dir":"Articles","previous_headings":"","what":"Q2: Practice using ggplot via scatterplots and facets","title":"BIOST 561: Homework 2","text":"Intent: question give basic practice using ggplot, mainly plotting scatterplots faceting plots. question, ’ll using dataset penguins Palmer Archipelago https://allisonhorst.github.io/palmerpenguins/reference/penguins.html. ’ve processed lightly homework. can see original documentation describing variables dataset. following code makes basic scatter plot. improving plot following sub-questions.  Question 2A: penguins dataset, change x-axis label y-axis label say Bill Depth (mm) Bill length (mm) respectively, well title plot write Relation among ??? penguins, use code count many rows penguins automatically (place ???). Additionally, color point based species, Adelie color cornflowerblue, Chinstrap color coral2, Gentoo color goldenrod3. (Hint: likely need scale_color_manual(), labs(), paste() functions.) (can see https://sites.stat.columbia.edu/tzheng/files/Rcolor.pdf see color names come .) Figure @ref(fig:scatterplot) shows plot trying reproduce. plot trying reproduce (without Sample watermark) Question 2A. Question 2B: now make following changes: 1) facet scatterplot based species, 2) add linear regression fit species (regression bill_length_mm onto bill_depth_mm) plot linear regression fit, 3) changing transparency points 50% transparent (.e., alpha=0.5). (Hint: question bit tricky since many things going . likely need geom_smooth() facet_wrap() functions.) Figure @ref(fig:facet) shows plot trying reproduce. plot trying reproduce (without Sample watermark) Question 2B.","code":"penguins <- readr::read_csv(\"https://raw.githubusercontent.com/linnykos/561_s2025_public/main/HW2_files/palmerpenguins.csv\") #> Rows: 333 Columns: 8 #> ── Column specification ──────────────────────────────────────────────────────── #> Delimiter: \",\" #> chr (3): species, island, sex #> dbl (5): bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g, year #>  #> ℹ Use `spec()` to retrieve the full column specification for this data. #> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. penguins #> # A tibble: 333 × 8 #>    species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g #>    <chr>   <chr>              <dbl>         <dbl>             <dbl>       <dbl> #>  1 Adelie  Torgersen           39.1          18.7               181        3750 #>  2 Adelie  Torgersen           39.5          17.4               186        3800 #>  3 Adelie  Torgersen           40.3          18                 195        3250 #>  4 Adelie  Torgersen           36.7          19.3               193        3450 #>  5 Adelie  Torgersen           39.3          20.6               190        3650 #>  6 Adelie  Torgersen           38.9          17.8               181        3625 #>  7 Adelie  Torgersen           39.2          19.6               195        4675 #>  8 Adelie  Torgersen           41.1          17.6               182        3200 #>  9 Adelie  Torgersen           38.6          21.2               191        3800 #> 10 Adelie  Torgersen           34.6          21.1               198        4400 #> # ℹ 323 more rows #> # ℹ 2 more variables: sex <chr>, year <dbl> penguins %>%   ggplot(aes(x = bill_depth_mm, y = bill_length_mm)) +   geom_point() penguins %>%   ggplot(aes(     x     = bill_depth_mm,     y     = bill_length_mm,     color = species   )) +   geom_point() +   scale_color_manual(     values = c(       \"Adelie\"    = \"cornflowerblue\",       \"Chinstrap\" = \"coral2\",       \"Gentoo\"    = \"goldenrod3\"     )   ) +   labs(     x     = \"Bill Depth (mm)\",     y     = \"Bill length (mm)\",     color = \"Species\",     title = paste0(       \"Relation among \",       nrow(penguins),       \" penguins\"     )   ) +   theme_minimal() penguins %>%   ggplot(aes(     x     = bill_depth_mm,     y     = bill_length_mm,     color = species   )) +   geom_point(alpha = 0.5) +                        geom_smooth(method = \"lm\", se = FALSE) +      scale_color_manual(     values = c(       \"Adelie\"    = \"cornflowerblue\",       \"Chinstrap\" = \"coral2\",       \"Gentoo\"    = \"goldenrod3\"     )   ) +   facet_wrap(~ species) +    labs(     x     = \"Bill Depth (mm)\",     y     = \"Bill length (mm)\",     color = \"Species\",     title = paste0(       \"Relation among \",       nrow(penguins),       \" penguins\"     )   ) +   theme_minimal() #> `geom_smooth()` using formula = 'y ~ x'"},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW2.html","id":"q3-practice-using-ggplot-via-heatmaps","dir":"Articles","previous_headings":"","what":"Q3: Practice using ggplot via heatmaps","title":"BIOST 561: Homework 2","text":"Intent: question give basic practice using ggplot, mainly plotting heatmaps. also see generate_random_graph() function future homeworks. Run following code load generate_random_graph(), generates adj_mat, random adjacency matrix (corresponding graph 20 nodes). row/column adj_mat corresponds one 20 nodes, value 0 1 denotes lack presence edge two nodes, respectively. Question 3A: Read provided generate_random_graph() works (either typing generate_random_graph R console reading code https://raw.githubusercontent.com/linnykos/561_s2025_public/main/HW2_files/random_graph_functions.R). three five sentences, describe generate_random_graph() . function builds network n points first choosing small group (clique) every point fully connected, sprinkling extra random connections among rest. makes sure connections go ways, removes point––links, shuffles points special group isn’t obvious. Finally, gives connection map list undo shuffle see points original clique. Question 3B: now write code produce heatmap visualize adj_mat. can happen, though, need one function convert adj_mat “long form,” necessity visualizing plot heatmap ggplot. See https://r-graph-gallery.com/heatmap.html. done via provided pivot_longer_heatmap() function: Read pivot_longer_heatmap() function (either typing pivot_longer_heatmap R console reading code https://raw.githubusercontent.com/linnykos/561_s2025_public/main/HW2_files/random_graph_functions.R). three five sentences, describe pivot_longer_heatmap() . Specifically, output pivot_longer_heatmap() relate adj_mat? (Hint: question, might helpful manually run function line--line R console see line code . hardest part question understanding pivot_longer function . function takes square adjacency matrix, labels rows columns nodes, reshapes three‑column table (X, Y, Value) row records connection (0 1) node X node Y. Look documentation function via ?tidyr::pivot_longer. might also helpful recall, R console, values adj_mat[1,1], adj_mat[1,2], adj_mat[1,3], … . look similar rows mat_long?) Question 3C: Now ready write code visualize mat_long heatmap. Write code using ggplot’s functions . want color 0 values palegoldenrod 1 values coral2. Please set aspect ratio plot 1:1 (.e., “boxes” squares) via coord_fixed() function. two four sentences, describe plot made relates adj_mat. (Hint: question tricky, even though need roughly 7 functions. likely want use geom_tile() scale_fill_manual() functions.)  Figure @ref(fig:adjmat) shows plot trying reproduce. plot trying reproduce (without Sample watermark) Question 3C. Question 3D: Congratulations! working pipeline visualize adjacency matrix. last question, combine functions visualize following:  can double-check see line code permutes rows columns. actual “graph” change (since ordering rows/columns arbitrary). Use provided pivot_longer_heatmap() function code Question 3C visualize adj_mat2. (mainly copy-pasting code previous questions now applying adj_mat2.) see dense set red blocks bottom-left corner heatmap. two sentences, plot tell us adj_mat2, turn, adj_mat? (Hint: Question 4 give context answer question.) can observe dense block left corner, indicating connected clique among nodes adj_mat2. clique also present adj_mat spread. Figure @ref(fig:adjmat2) shows plot trying reproduce. plot trying reproduce (without Sample watermark) Question 3D.","code":"source(\"https://raw.githubusercontent.com/linnykos/561_s2025_public/main/HW2_files/random_graph_functions.R\") set.seed(0) result <- generate_random_graph(n = 20,                                 clique_fraction = 0.5,                                 density_low = 0.1) adj_mat <- result$adj_mat dim(adj_mat) #> [1] 20 20 adj_mat[1:5,1:5] #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    1    0    1    0    0 #> [2,]    0    1    1    1    1 #> [3,]    1    1    1    0    0 #> [4,]    0    1    0    1    0 #> [5,]    0    1    0    0    1 mat_long <- pivot_longer_heatmap(adj_mat) mat_long #> # A tibble: 400 × 3 #>        X     Y Value #>    <int> <dbl> <dbl> #>  1     1     1     1 #>  2     1     2     0 #>  3     1     3     1 #>  4     1     4     0 #>  5     1     5     0 #>  6     1     6     1 #>  7     1     7     0 #>  8     1     8     0 #>  9     1     9     0 #> 10     1    10     0 #> # ℹ 390 more rows ggplot(mat_long, aes(x = X, y = Y, fill = factor(Value))) +   geom_tile() +   scale_fill_manual(values = c(\"0\" = \"palegoldenrod\", \"1\" = \"coral2\")) +   coord_fixed() +   theme_minimal() +   labs(x = \"Node X\", y = \"Node Y\", fill = \"Connection\") adj_mat2 <- result$adj_mat[result$rev_order, result$rev_order]  mat_long2 <- pivot_longer_heatmap(adj_mat2) mat_long2 #> # A tibble: 400 × 3 #>        X     Y Value #>    <int> <dbl> <dbl> #>  1     1     1     1 #>  2     1     2     1 #>  3     1     3     1 #>  4     1     4     1 #>  5     1     5     1 #>  6     1     6     1 #>  7     1     7     1 #>  8     1     8     1 #>  9     1     9     1 #> 10     1    10     1 #> # ℹ 390 more rows  ggplot(mat_long2, aes(x = X, y = Y, fill = factor(Value))) +   geom_tile() +   scale_fill_manual(values = c(\"0\" = \"palegoldenrod\", \"1\" = \"coral2\")) +   coord_fixed() +   theme_minimal() +   labs(x = \"Node X\", y = \"Node Y\", fill = \"Connection\")"},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW2.html","id":"q4-planning-for-the-next-homework-thinking-how-to-test-a-function","dir":"Articles","previous_headings":"","what":"Q4: Planning for the next homework – thinking how to test a function","title":"BIOST 561: Homework 2","text":"Intent: question get started think testing function. Question 3 demonstrates “planted clique” – might clique random graph (.e., collection connected nodes). clique might evident first glance (demonstrated Question 3C), permute rows columns (done Question 3D), clique quite apparent. (Lecture 4, go basics thinking graphs adjacency matrices. Please watch Panopto recording Canvas want context.) Suppose teammate gave function find maximal clique adjacency matrix (.e., set nodes forms largest clique). told typical size characteristics adjacency matrices beforehand. job make sure function correct since teammate give function manager, give another division company use. performance review depend highly whether people company can reliably use function. short paragraph, write ways ensure teammate’s function “correct.” Please list least four different ways can test function. can interpret notion “correct” liberally – question purposely framed open-ended. (purposely giving implementation function. Please use ChatGPT specific question.) (curious, “Maximal Clique Problem” (MCP), classic example “hard” problem Computer Science theory. See https://arxiv.org/abs/2403.09742. need read paper complete question – ’s simply additional reading curious students.) Check correctness: review input function matrix output matrix Provide two matrices different clique size make sure ouput different Check extreme cases: provide matrix clique check detected. well provide matrix everyone conected check output. Compare function “validated” functions","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW2.html","id":"q5-feedback-optional","dir":"Articles","previous_headings":"","what":"Q5: Feedback (Optional)","title":"BIOST 561: Homework 2","text":"“question” additional way students communicate instructors. include positive feedback topics enjoyed learning module, critiques course difficulty/pacing, questions/confusions course material. feedback can help shape course rest quarter future years. Please mindful polite providing feedback. may leave question blank. enjoyed learning test function. done past never thought systematic way.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW3.html","id":"instructions","dir":"Articles","previous_headings":"","what":"Instructions","title":"BIOST 561: Homework 3","text":"instructions essential, please read carefully. Submit homework GitHub page RMarkdown (.Rmd) HTML files. Please answer question prompt show code (inline). , code visible knitted chunks. complete homework, may write HW3.Rmd file. (recommended complete homework R Studio, clicking Knit button knit homework.)","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW3.html","id":"disclosures","dir":"Articles","previous_headings":"","what":"Disclosures","title":"BIOST 561: Homework 3","text":"Please disclose collaborated ’ve used ChatGPT (comparable AI tool) extent completing homework. See syllabus course expectations. (Note: homework substantially challenging Homework 2 since homework much open-ended. feel stuck homework, feel free consult ChatGPT. ChatGPT can give strategies tackling problem, code tackle problem, explanation step code works. Try using ChatGPT part workflow. homework get realize writing “code gets job done” (important) tiny part means “strong coder.”)","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW3.html","id":"note-about-the-homework","dir":"Articles","previous_headings":"","what":"Note about the homework","title":"BIOST 561: Homework 3","text":"Note: R code homework homework. mainly write .R files inside R tests folders. Therefore, need show little code inside R Markdown file. need write things inside R Markdown file questions explicitly ask .","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW3.html","id":"q1-designing-a-function-to-generate-random-graphs-with-partial-cliques","dir":"Articles","previous_headings":"","what":"Q1: Designing a function to generate random graphs with partial cliques","title":"BIOST 561: Homework 3","text":"Intent: intent question : 1) give practice putting R functions UWBiost561 package, 2) help create ways test function Question 3 meaningfully. Recall generate_random_graph() function used Homework 2. (deliberately open-ended) goal question design function generate_partial_clique() generates random adjacency matrix large partial clique, necessarily (fully connected) clique. Question 1A: Create function generate_partial_clique() inside UWBiost561 package inside file called generate_partial_clique.R inside R folder. (nothing report question. code R folder, R Markdown file.) Specifications function overall: function must called generate_partial_clique. function must file called generate_partial_clique.R R folder within UWBiost561 package. write additional “helper” functions generate_partial_clique() depends , additional functions must also generate_partial_clique.R. , generate_partial_clique.R “self-contained.” code must written R. (write code C++, Java, Python.) Specifications function inputs: first, second, third arguments generate_partial_clique() must called n, clique_fraction, clique_edge_density respectively. function check n argument positive integer. argument represents number nodes graph (literal sense, number rows columns outputted adjacency matrix). function check clique_fraction argument single numeric 0 1 (inclusive). argument represents fraction nodes (n nodes) part partial clique. (, least round(n*clique_fraction) nodes part partial clique.) function check clique_edge_density argument single numeric 0 1 (inclusive). argument represents edge density among nodes clique. (example, generate_random_graph() used Homework 2 essentially clique_edge_density=1, adjacency matrix worked Homework 2 (fully connected) clique.) Specifically, means partial clique m=round(n*clique_fraction) nodes, (fully connected) clique m*(m-1)/2 (.e., m choose 2) edges. partial clique edge density clique_edge_density instead least round(clique_edge_density*m*(m-1)/2) edges among m nodes. function may take arguments, every argument n, clique_fraction clique_edge_density must default value. use function, user need set argument aside n, clique_fraction clique_edge_density. Specifications function outputs: must output list. first named element must specifically adj_mat. random adjacency matrix construct partial clique. Specifically, adj_mat symmetric matrix values 0 1, 2) 1’s along diagonal, 3) row- column-names. (construction, partial clique consisting least round(clique_fraction*n) nodes edge density clique_edge_density.) may optionally return additional outputs (within reason) function might need testing/debugging. Note: purposely specify necessary ingredients create random graph. can design function long satisfies required specifications. However, realize start testing function Question 3, ways create graphs partial cliques “easy” “aren’t useful” testing compute_maximal_partial_clique() Question 2. Question 1B: Following demo showed Lecture 4, create ROxygen skeleton generate_partial_clique() function inside generate_partial_clique.R file. Write meaningful documentation generate_partial_clique() function. Importantly, exported via @export tag. (nothing report question. ROxygen skeleton R Markdown file) Question 1C: Install R package. can using R Studio running devtools::install() R console. (nothing report question. R Markdown file.) might find https://docs.google.com/document/d/17lskKfgMdLSi3SroQMdodqmHWjxeyNPnXTxM3beoCM8/edit?usp=sharing useful difficulty installing UWBiost561 package. Question 1D: homework’s R Markdown file, show generate_partial_clique() function works. Specifically, run following lines. (copy-pasting following R chunk, remove eval = FALSE tag.) get full marks markdown shows code chunk shows code outputted matrix res$adj_mat . Congratulations! ’ve just made function R package!","code":"source(\"https://raw.githubusercontent.com/linnykos/561_s2025_public/main/HW2_files/random_graph_functions.R\") generate_random_graph #> function (n, clique_fraction = 0.2, density_low = 0.1)  #> { #>     stopifnot(n%%1 == 0, n >= 0, clique_fraction >= 0, clique_fraction <=  #>         1, density_low >= 0, density_low <= 1) #>     adj_mat <- matrix(sample(x = c(0, 1), size = n^2, prob = c(1 -  #>         density_low, density_low), replace = TRUE), nrow = n,  #>         ncol = n) #>     adj_mat <- adj_mat + t(adj_mat) #>     adj_mat[adj_mat > 0] <- 1 #>     diag(adj_mat) <- 1 #>     clique_size <- ceiling(n * clique_fraction) #>     adj_mat[1:clique_size, 1:clique_size] <- 1 #>     sample_idx <- sample(1:n) #>     adj_mat <- adj_mat[sample_idx, sample_idx] #>     rev_order <- sapply(1:n, function(i) { #>         which(sample_idx == i) #>     }) #>     return(list(adj_mat = adj_mat, rev_order = rev_order)) #> } library(UWBiost561) set.seed(0) simulation <- UWBiost561::generate_partial_clique(   n = 10,   clique_fraction = 0.5,   clique_edge_density = 0.9 )  simulation$adj_mat #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #>  [1,]    1    1    0    1    1    0    1    0    0     0 #>  [2,]    1    1    0    1    1    0    1    0    0     0 #>  [3,]    0    0    1    0    0    0    0    0    0     0 #>  [4,]    1    1    0    1    1    0    1    0    0     0 #>  [5,]    1    1    0    1    1    0    0    0    0     0 #>  [6,]    0    0    0    0    0    1    0    0    0     0 #>  [7,]    1    1    0    1    0    0    1    0    0     1 #>  [8,]    0    0    0    0    0    0    0    1    0     0 #>  [9,]    0    0    0    0    0    0    0    0    1     0 #> [10,]    0    0    0    0    0    0    1    0    0     1"},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW3.html","id":"q2-designing-a-function-to-find-the-maximal-partial-clique","dir":"Articles","previous_headings":"","what":"Q2: Designing a function to find the maximal partial clique","title":"BIOST 561: Homework 3","text":"Intent: intent question : 1) give practice developing function “open-ended”, 2) emulate realistic coding experience. code write play huge role Homework 4, look function fellow students write vice versa. Question 2A: Create function compute_maximal_partial_clique() inside UWBiost561 package computes largest partial clique given adjacency matrix adj_mat required edge density alpha. (nothing report question. code R folder, R Markdown file.) Illustration adjacency matrix (left), , reorder nodes (right, similar HW2), ’ll see first 9 nodes 95% partial clique. Note: maximal partial clique (.e., specific set nodes) might unique! always uniquely defined size maximal partial clique valid inputs adj_mat alpha. (adj_mat empty graph, .e., just diagonal matrix, maximal partial clique size 1: node clique .) Realistically, function sometimes get correct maximal partial clique (even unique) since “correct” maximal partial clique requires unreasonable computationally resources. Effectively, correct answer task. goal instead give reasonable answer (define ). coding tasks data analyses encounter “real world” definitive, well-defined “correct” answer! Specifications function overall: function must called compute_maximal_partial_clique. function must file called compute_maximal_partial_clique.R R folder within UWBiost561 package. write additional “helper” functions compute_maximal_partial_clique() depends , additional functions must also compute_maximal_partial_clique.R. , compute_maximal_partial_clique.R “self-contained.” code must written R. (write code C++, Java, Python.) Time efficiency: input adj_mat 30 30 (.e., 30 nodes), method take 30 seconds complete . Specifications function inputs: first second arguments compute_maximal_partial_clique() must called adj_mat alpha respectively. function check adj_mat argument : 1) symmetric matrix values 0 1, 2) 1’s along diagonal, 3) row- column-names, 4) 5 50 rows/columns (inclusive). function check alpha argument : 1) single numeric (.e., length 1), 2) value 0.5 1 (inclusive). function may take arguments, every argument adj_mat alpha must default value. use function, user need set argument aside adj_mat alpha. Specifications function outputs: must output list. list must contain least two named elements, specifically first second elements: first named element must specifically clique_idx. numeric vector index numbers corresponding nodes (.e., values 1 nrow(adj_mat)) function deems maximum partial clique. vector duplicate elements, must positive integers, largest value exceed nrow(adj_mat). Specifically, means function elect adj_mat[clique_idx,clique_idx] maximal partial clique, meaning: 1) m=length(clique_idx), (sum(adj_mat[clique_idx,clique_idx])-m)/2 >= alpha*m*(m-1)/2, ensures number edges among nodes clique_idx (100*alpha)% full clique size m, 2) size clique_idx (reasonably) increased without making valid partial clique density alpha. (Remember: easy ensure condition #1, hard guarantee condition #2.) second named element must specifically edge_density. percentage edges adj_mat among nodes clique_idx. (calculation given demo code .) Specifically, number 0 1 (inclusive), (computed correctly length clique_idx larger one) always greater equal alpha construction. may optionally return additional outputs (within reason) function might need testing/debugging. Rules/Guidelines using external packages: function can use packages CRAN. (, packages GitHub Bioconductor.) best knowledge, code also use functions depend language C C++. (packages functions use invoke Java Python code.) use function directly solves maximal partial clique. (Please ask Canvas discussions unsure function intend use violates rule.) Please (best can) design code depend packages possible. rough skeleton compute_maximal_partial_clique() might look like: Note: expected know many “algorithms” course. Hence, 1) understand task 2) still trying figure approach question, please consult ChatGPT. Lectures 5 6 give live demonstrations “code ChatGPT.” feel overwhelmed question, can use ChatGPT help . (okay long function works follows specifications question – might need modify ChatGPT’s code.) However, can guarantee ChatGPT give anywhere close “optimal” solution task (many senses word). problem provably “correct solution can feasibly used.” Hence, feel courageous know algorithms, can go rabbit hole see design better algorithm. assessing implementation based demonstrating “good faith effort,” based whether function outputs “correct” maximal partial clique. receive full credit function works, provides reasonable outputs, passes unit tests (Question 3). Question 2B: Similar Question 1B 1C, create ROxygen skeleton compute_maximal_partial_clique() function inside compute_maximal_partial_clique.R file. Write meaningful documentation compute_maximal_partial_clique() function. Importantly, exported via @export tag. , install UWBiost561 package . (nothing report question. ROxygen skeleton R Markdown file) ROxygen skeleton include two five sentences method works. Question 2C: Demonstrate (R Markdown file) compute_maximal_partial_clique() works random adjacency matrix outputted function generate_partial_clique(). Specifically, run following lines. (copy-pasting following R chunk, remove eval = FALSE tag.) question purposefully open-ended. goal simply show output compute_maximal_partial_clique() function based adjacency matrix generate_partial_clique() “reasonable.”","code":"# This is NOT a good implementation. # This is solely for demonstration. # This lousy function simply picks a random set of nodes. # It doesn't actually compute the valid partial clique! compute_maximal_partial_clique <- function(adj_mat, alpha){   n <- nrow(adj_mat)   clique_idx <- sample(1:n, size = ceiling(n/2))   m <- length(clique_idx)      edge_density_numerator <- (sum(adj_mat[idx,idx]) - m)/2   edge_density_denominator <- m*(m-1)/2   edge_density <- edge_density_numerator/edge_density_denominator      return(list(clique_idx = clique_idx,               edge_density = edge_density)) } library(UWBiost561) set.seed(0) simulation <- UWBiost561::generate_partial_clique(   n = 10,   clique_fraction = 0.5,   clique_edge_density = 0.9 )  adj_mat <- simulation$adj_mat  res <- UWBiost561::compute_maximal_partial_clique(   adj_mat = adj_mat,   alpha = 0.9 ) res #> $clique_idx #> [1] 1 2 4 5 7 #>  #> $edge_density #> [1] 0.9"},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW3.html","id":"q3-developing-unit-tests-for-your-functions","dir":"Articles","previous_headings":"","what":"Q3: Developing unit tests for your functions","title":"BIOST 561: Homework 3","text":"Intent: intent question give experience writing unit tests inside UWBiost561 package. Question 3A: Following overview Lecture 5, well additional walkthrough https://docs.google.com/document/d/17lskKfgMdLSi3SroQMdodqmHWjxeyNPnXTxM3beoCM8/edit?usp=sharing, create tests folder UWBiost561 package contains testthat.R file (shown ) well testthat folder. (nothing report question.) Question 3B: Write least two unit tests generate_partial_clique() function inside file called test_generate_partial_clique.R within testthat folder. (nothing report question. code tests/testthat folder, R Markdown file.) Question 3C: Writing least five unit tests compute_maximal_partial_clique() function inside file called test_compute_maximal_partial_clique.R within testthat folder. Based “List types unit-tests” page Lecture 5, ensure five unit tests “different category.” (nothing report question. code tests/testthat folder, R Markdown file.) pointers: use generate_partial_clique() within tests compute_maximal_partial_clique(). Since constructing random adjacency matrix partial clique least edge density clique_edge_density size round(n*clique_fraction), expect “simple” random adjacency matrices, compute_maximal_partial_clique() can recover partial clique constructed. Question 3D: Run devtools::test() R package UWBiost561 ’re R project. (nothing report question. code R console, R Markdown file.)","code":"# This is what your testthat.R file should contain library(testthat) library(UWBiost561)  testthat::test_check(\"UWBiost561\")"},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW3.html","id":"q4-finalizing-your-r-package","dir":"Articles","previous_headings":"","what":"Q4: Finalizing your R package","title":"BIOST 561: Homework 3","text":"Intent: intent question experience basics making R package. Question 4A: Fix DESCRIPTION file needed. Importantly, involves adding R package dependencies generate_partial_clique() compute_maximal_partial_clique() depend . (none, don’t need worry .) also replace default author, package title, description something meaningful. (nothing report question.) Question 4B: R project UWBiost561 package, run command usethis::use_mit_license() R console. (nothing report question.) point, R package following. File specifically called generate_partial_clique.R File specifically called compute_maximal_partial_clique.R File specifically called testthat.R File specifically called test_generate_partial_clique.R File specifically called test_compute_maximal_partial_clique.R Multiple files, including files HW1.Rmd, HW1.html, HW2.Rmd, HW2.html, HW3.Rmd, HW3.html (analogously named) File specifically called DESCRIPTION File specifically called LICENSE File specifically called .Rbuildignore (potential files) Question 4B: Run devtools::check(). Ensure errors, ’s okay don’t want fix warnings. (devtools::check() also automatically generate man folder documentation converted ROxygen code NAMESPACE file.) might take fix errors devtools::check() complains – advise using Google determine exactly unhappy , can ask Canvas Discussion board. (nothing report question. code R console, R Markdown file.) Question 4C: Include screenshots devtools::check() result R Markdown file. (guideline, one screenshot show first 20--lines devtools::check() results, second screenshot show last 20--lines results.) can use knitr::include_graphics() function include figures inside R Markdown file. intent question provide “evidence” devtools::check() went smoothly. need worry screenshots show specifically. Figure @ref(fig:check1) @ref(fig:check2) shows screenshots trying reproduce. first screenshot trying reproduce (without Sample watermark) Question 4C. second screenshot trying reproduce (without Sample watermark) Question 4C. Question 4D: Please include following code chunk’s result Markdown file. (copy-pasting following R chunk, remove eval = FALSE tag.) useful (Kevin) assess packages R version using.","code":"# knitr::include_graphics(\"C:/Users/jrjor/Pictures/Screenshots/Screenshot 2025-05-12 102336.png\") # knitr::include_graphics(\"C:/Users/jrjor/Pictures/Screenshots/Screenshot 2025-05-12 102237.png\")"},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW3.html","id":"q5-storyline-for-hw4-and-final-project","dir":"Articles","previous_headings":"","what":"Q5: Storyline for HW4 and final project","title":"BIOST 561: Homework 3","text":"Intent: intent question prepare HW4 final project. Please read: expect HW4: HW4, curating every student’s implementation compute_maximal_partial_clique() provide one folder contains every student’s (anonymized) implementation. , : code review two different implementations assign specifically (involves reading code well seeing implementations pass unit tests) Performing modest simulation study compares implementations terms 1) size maximal partial clique found, 2) time takes complete, 3) often crashes gives invalid output. Bayes (Biostat servers). reason, strongly encourage take diligence testing code since every student soon trying implementation simulated adjacency matrices. Question 5A: Please make sure can install Husky OnNet use UW VPN. installation instructions : https://uwconnect.uw.edu/?id=kb_article_view&sysparm_article=KB0034247 useful links: Instructions wrote lab: https://docs.google.com/document/d/1FGdD3O7nL-xQfPRefHb9fxmqf43HYHGLgD-V4UZC6ec/edit?usp=sharing https://uwconnect.uw.edu/?id=kb_article_view&sysparm_article=KB0034243 – talks exactly ’re downloading. Question 5B: sentences, please describe think ’d like make final project. 100% okay “reuse” R code another course (either past current, even previous institution). Ideally, R code care . write committal – can change idea anytime. intent question get start thinking . think , maybe use function data analysis project working . full project specifications released weeks. give sense expect, ’ll making PkgDown website looks like https://linnykos.github.io/561_s2025_example/. Briefly, involve: R package includes R code (possibly code languages) solve problem. problem can large small scope want. Unit tests R functions. Documentation exported R functions. vignette explains use R functions. vignette “self-contained” (, include explicit directions downloading data, package R function generate synthetic data). README page explains purpose R package. public PkgDown website R package hosted via GitHub. (can take website grade course submitted.) R project mind, full project specifications give specific directions using UWBiost561 package satisfy requirements. However, experience feel meaningful use something value foundation final project. (project intended take long time. Ideally, choose coding project care foundation final project, already R code, remains “everything else.” care many complex functions . Realistically, can use just meaningful subset functions existing code base project.) Question 5B: Push code onto GitHub. includes contents inside R tests folder DESCRIPTION, NAMESPACE, LICENSE files. Please double-check can see necessary files online GitHub website (.e., https://github.com/). (nothing report question.)","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW3.html","id":"q6-feedback-optional","dir":"Articles","previous_headings":"","what":"Q6: Feedback (Optional)","title":"BIOST 561: Homework 3","text":"“question” additional way students communicate instructors. include positive feedback topics enjoyed learning module, critiques course difficulty/pacing, questions/confusions course material. feedback can help shape course rest quarter future years. Please mindful polite providing feedback. may leave question blank.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW4.html","id":"instructions","dir":"Articles","previous_headings":"","what":"Instructions","title":"BIOST 561: Homework 4","text":"instructions essential, please read carefully. Submit homework GitHub page RMarkdown (.Rmd) HTML files. Please answer question prompt show code (inline). , code visible knitted chunks. complete homework, may write HW3.Rmd file. (recommended complete homework R Studio, clicking Knit button knit homework.)","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW4.html","id":"disclosures","dir":"Articles","previous_headings":"","what":"Disclosures","title":"BIOST 561: Homework 4","text":"Please disclose collaborated ’ve used ChatGPT (comparable AI tool) extent completing homework. See syllabus course expectations.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW4.html","id":"note-about-the-homework","dir":"Articles","previous_headings":"","what":"Note about the homework","title":"BIOST 561: Homework 4","text":"Note: R code homework homework. mainly write .R files inside R tests folders. Therefore, need show little code inside R Markdown file. need write things inside R Markdown file questions explicitly ask . Please use https://docs.google.com/document/d/1369bf2WE7n2FzhFoqUv2rgWMZRurYfjHmGMUNHfOWBU/edit?usp=sharing resource homework.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW4.html","id":"code-of-conduct-for-this-homework","dir":"Articles","previous_headings":"","what":"Code of conduct for this homework","title":"BIOST 561: Homework 4","text":"Please respectful peers homework. student’s compute_maximal_partial_clique() function anonymized used every student homework. implementations function work smoother others. Nonetheless, 1) please respectful implementations throughout homework, might realize ’re talking author implementation, 2) please feel embarrassed (knowing implementation , since wrote ) work well initially thought.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW4.html","id":"q1-doing-a-code-review-of-two-other-implementations","dir":"Articles","previous_headings":"","what":"Q1: Doing a code review of two other implementations","title":"BIOST 561: Homework 4","text":"Intent: intent question review implementations. see sense coding compares peers. Note 1: instructions HW3 unclear define density clique size one (.e., just one node) – (Kevin) apologize. Let’s define edge density 1 node 1 (returning set 1 node always valid clique, albeit largest one). GitHub Issues HW3, assigned two compute_maximal_partial_clique implementations review. example, assigned #1 #3, reviewing implementations compute_maximal_partial_clique1() compute_maximal_partial_clique3(). Question 1A: gone Lecture 8 install compute_maximal_partial_clique implementations UWBiost561 package. short, find zip file Canvas called hw4_implementations.zip. Download , unzip file. see bunch functions files--put--R-folder folder, including compute_maximal_partial_clique_master.R many compute_maximal_partial_clique implementations (.R file). Copy paste files R folder UWBiost561 package. ’ve done things, run devtools::check() add documentation compute_maximal_partial_clique functions. (warnings errors completion HW3, still warnings errors now.) , run devtools::install() install new UWBiost561 package. (nothing report question. make changes R Markdown file.) Question 1B: Looking two implementations given, summarize think implementations one four sentences . (practice reading people’s code.) compute_maximal_partial_clique3: function first checks adj_mat valid symmetric binary adjacency matrix size 5 50 ones diagonal (row column names) alpha lies 0.5 1. warns 10 nodes, since search cliques size 10. iterates largest allowed clique size (10 number nodes) 2, generating combinations nodes size computing subgraph’s edge density. soon finds subset whose edge density meets exceeds alpha, records node indices density, stops search, returns . compute_maximal_partial_clique8: function first checks adj_mat symmetric binary adjacency matrix ones diagonal, 5 50 nodes, alpha single numeric value 0.5 1. initializes clique_idx include node indices repeatedly computes edge density current subgraph; density remains alpha one node remains, removes node fewest connections. subgraph’s edge density meets exceeds alpha (one node left), calculates final density retained nodes returns node indices along density. Question 1C: terms coding clarity (.e., whether code gives good answer), recommendations give original author code improve code’s clarity? can documentation, variable naming, whether code factorized dedicated functions, portion code hard understand, etc. Give none two suggestions implementation. (can give suggestions thought code spectacular – even ’s returning great answer, can easily understand code despite written someone else.) compute_maximal_partial_clique8: Rename helper functions (e.g., .peel_node_8 remove_lowest_degree_node .obtain_density_8 compute_edge_density) immediate clarity. Question 1D: HW3, wrote least 5 unit tests implementation compute_maximal_partial_clique(). R Markdown file (.e., tests folder), copy-paste 5 unit tests see two compute_maximal_partial_clique implementations assigned pass unit tests. assigned implementations #2 #7, test functions compute_maximal_partial_clique2() compute_maximal_partial_clique7(). Note 1: 5 unit tests, need try 5 question. Since ’re testing two implementations, ’ll 10 unit tests total. Note 2: copy-pasting unit tests, can directly copy-paste entire testthat() function R Markdown file contents testthat(). (See example R Markdown file . , can either use library(testthat) R Markdown file prefix test_that() functions testthat::.) Note 3: can write two large R code chunks, one implementation’s 5 unit tests. Since implementation ’ve assigned might necessarily pass unit tests, please set error = TRUE flag R code chunk options. (See example R Markdown file .) Note 4: like test things weren’t HW3, feel free . (tests question don’t literally need ones created HW3.)","code":"# implementation 3  # 1. Simple known clique recovery (functional test) test_that(\"compute_maximal_partial_clique recovers a full clique\", {   # Build a 5-node full clique   A <- matrix(1L, nrow = 5, ncol = 5)   diag(A) <- 1L    # alpha = 1 means require 100% density   res <- compute_maximal_partial_clique3(A, alpha = 1)   expect_setequal(res$clique, seq_len(5)) }) #> ── Error: compute_maximal_partial_clique recovers a full clique ──────────────── #> Error in `compute_maximal_partial_clique3(A, alpha = 1)`: could not find function \"compute_maximal_partial_clique3\" #> Error: #> ! Test failed  # 2. Partial clique recovery in a small graph (integration test) test_that(\"recover partial clique of size 3 in 6-node graph\", {   A <- matrix(0L, 6, 6)   diag(A) <- 1L   # clique on nodes 2,4,6 fully connected   pairs <- combn(c(2,4,6), 2)   for(j in seq_len(ncol(pairs))) {     i <- pairs[1,j]; k <- pairs[2,j]     A[i,k] <- A[k,i] <- 1L   }   # alpha = 1 again, since our \"partial\" clique is full within those 3 nodes   res <- compute_maximal_partial_clique3(A, alpha = 1)   expect_setequal(res$clique, c(2,4,6)) }) #> ── Error: recover partial clique of size 3 in 6-node graph ───────────────────── #> Error in `compute_maximal_partial_clique3(A, alpha = 1)`: could not find function \"compute_maximal_partial_clique3\" #> Error: #> ! Test failed   # 3. Extreme case 1: too small adjacency matrix (n < 5) should error test_that(\"error if adjacency matrix has fewer than 5 nodes\", {   A4 <- diag(4)          # 4×4 identity: meets most checks but n < 5   expect_error(     compute_maximal_partial_clique3(A4, alpha = 0.5),     \"`adj_mat` must have between 5 and 50 rows/columns\"   ) }) #> ── Error: error if adjacency matrix has fewer than 5 nodes ───────────────────── #> Error in `compute_maximal_partial_clique3(A4, alpha = 0.5)`: could not find function \"compute_maximal_partial_clique3\" #> Backtrace: #>     ▆ #>  1. └─testthat::expect_error(...) #>  2.   └─testthat:::expect_condition_matching(...) #>  3.     └─testthat:::quasi_capture(...) #>  4.       ├─testthat (local) .capture(...) #>  5.       │ └─base::withCallingHandlers(...) #>  6.       └─rlang::eval_bare(quo_get_expr(.quo), quo_get_env(.quo)) #> Error: #> ! Test failed  # 4. Error on non-symmetric input (error test) test_that(\"error if adjacency matrix is not symmetric\", {   # 5×5 identity passes size, diag, 0/1 checks   A <- diag(5)   # introduce asymmetry: (1,2)=0, but (2,1)=1   A[1,2] <- 0L   A[2,1] <- 1L   expect_error(     compute_maximal_partial_clique3(A, alpha = 0.5),     \"`adj_mat` must be symmetric\"   ) }) #> ── Error: error if adjacency matrix is not symmetric ─────────────────────────── #> Error in `compute_maximal_partial_clique3(A, alpha = 0.5)`: could not find function \"compute_maximal_partial_clique3\" #> Backtrace: #>     ▆ #>  1. └─testthat::expect_error(...) #>  2.   └─testthat:::expect_condition_matching(...) #>  3.     └─testthat:::quasi_capture(...) #>  4.       ├─testthat (local) .capture(...) #>  5.       │ └─base::withCallingHandlers(...) #>  6.       └─rlang::eval_bare(quo_get_expr(.quo), quo_get_env(.quo)) #> Error: #> ! Test failed  # 5. Error on alpha test_that(\"error if alpha is outside [0.5, 1]\", {   A <- diag(5)   # too low   expect_error(     compute_maximal_partial_clique3(A, alpha = 0.4),     \"`alpha` must be between 0.5 and 1\"   )   # too high   expect_error(     compute_maximal_partial_clique3(A, alpha = 1.1),     \"`alpha` must be between 0.5 and 1\"   ) }) #> ── Error: error if alpha is outside [0.5, 1] ─────────────────────────────────── #> Error in `compute_maximal_partial_clique3(A, alpha = 0.4)`: could not find function \"compute_maximal_partial_clique3\" #> Backtrace: #>     ▆ #>  1. └─testthat::expect_error(...) #>  2.   └─testthat:::expect_condition_matching(...) #>  3.     └─testthat:::quasi_capture(...) #>  4.       ├─testthat (local) .capture(...) #>  5.       │ └─base::withCallingHandlers(...) #>  6.       └─rlang::eval_bare(quo_get_expr(.quo), quo_get_env(.quo)) #> Error: #> ! Test failed # implementation 8   # 1. Simple known clique recovery (functional test) test_that(\"compute_maximal_partial_clique recovers a full clique\", {   # Build a 5-node full clique   A <- matrix(1L, nrow = 5, ncol = 5)   diag(A) <- 1L    # alpha = 1 means require 100% density   res <- compute_maximal_partial_clique8(A, alpha = 1)   expect_setequal(res$clique, seq_len(5)) }) #> ── Error: compute_maximal_partial_clique recovers a full clique ──────────────── #> Error in `compute_maximal_partial_clique8(A, alpha = 1)`: could not find function \"compute_maximal_partial_clique8\" #> Error: #> ! Test failed  # 2. Partial clique recovery in a small graph (integration test) test_that(\"recover partial clique of size 3 in 6-node graph\", {   A <- matrix(0L, 6, 6)   diag(A) <- 1L   # clique on nodes 2,4,6 fully connected   pairs <- combn(c(2,4,6), 2)   for(j in seq_len(ncol(pairs))) {     i <- pairs[1,j]; k <- pairs[2,j]     A[i,k] <- A[k,i] <- 1L   }   # alpha = 1 again, since our \"partial\" clique is full within those 3 nodes   res <- compute_maximal_partial_clique8(A, alpha = 1)   expect_setequal(res$clique, c(2,4,6)) }) #> ── Error: recover partial clique of size 3 in 6-node graph ───────────────────── #> Error in `compute_maximal_partial_clique8(A, alpha = 1)`: could not find function \"compute_maximal_partial_clique8\" #> Error: #> ! Test failed   # 3. Extreme case 1: too small adjacency matrix (n < 5) should error test_that(\"error if adjacency matrix has fewer than 5 nodes\", {   A4 <- diag(4)          # 4×4 identity: meets most checks but n < 5   expect_error(     compute_maximal_partial_clique8(A4, alpha = 0.5),     \"`adj_mat` must have between 5 and 50 rows/columns\"   ) }) #> ── Error: error if adjacency matrix has fewer than 5 nodes ───────────────────── #> Error in `compute_maximal_partial_clique8(A4, alpha = 0.5)`: could not find function \"compute_maximal_partial_clique8\" #> Backtrace: #>     ▆ #>  1. └─testthat::expect_error(...) #>  2.   └─testthat:::expect_condition_matching(...) #>  3.     └─testthat:::quasi_capture(...) #>  4.       ├─testthat (local) .capture(...) #>  5.       │ └─base::withCallingHandlers(...) #>  6.       └─rlang::eval_bare(quo_get_expr(.quo), quo_get_env(.quo)) #> Error: #> ! Test failed  # 4. Error on non-symmetric input (error test) test_that(\"error if adjacency matrix is not symmetric\", {   # 5×5 identity passes size, diag, 0/1 checks   A <- diag(5)   # introduce asymmetry: (1,2)=0, but (2,1)=1   A[1,2] <- 0L   A[2,1] <- 1L   expect_error(     compute_maximal_partial_clique8(A, alpha = 0.5),     \"`adj_mat` must be symmetric\"   ) }) #> ── Error: error if adjacency matrix is not symmetric ─────────────────────────── #> Error in `compute_maximal_partial_clique8(A, alpha = 0.5)`: could not find function \"compute_maximal_partial_clique8\" #> Backtrace: #>     ▆ #>  1. └─testthat::expect_error(...) #>  2.   └─testthat:::expect_condition_matching(...) #>  3.     └─testthat:::quasi_capture(...) #>  4.       ├─testthat (local) .capture(...) #>  5.       │ └─base::withCallingHandlers(...) #>  6.       └─rlang::eval_bare(quo_get_expr(.quo), quo_get_env(.quo)) #> Error: #> ! Test failed  # 5. Error on alpha test_that(\"error if alpha is outside [0.5, 1]\", {   A <- diag(5)   # too low   expect_error(     compute_maximal_partial_clique8(A, alpha = 0.4),     \"`alpha` must be between 0.5 and 1\"   )   # too high   expect_error(     compute_maximal_partial_clique8(A, alpha = 1.1),     \"`alpha` must be between 0.5 and 1\"   ) }) #> ── Error: error if alpha is outside [0.5, 1] ─────────────────────────────────── #> Error in `compute_maximal_partial_clique8(A, alpha = 0.4)`: could not find function \"compute_maximal_partial_clique8\" #> Backtrace: #>     ▆ #>  1. └─testthat::expect_error(...) #>  2.   └─testthat:::expect_condition_matching(...) #>  3.     └─testthat:::quasi_capture(...) #>  4.       ├─testthat (local) .capture(...) #>  5.       │ └─base::withCallingHandlers(...) #>  6.       └─rlang::eval_bare(quo_get_expr(.quo), quo_get_env(.quo)) #> Error: #> ! Test failed rowSums(1:5) #> Error in rowSums(1:5): 'x' must be an array of at least two dimensions \"asdf\" + \"1234\" #> Error in \"asdf\" + \"1234\": non-numeric argument to binary operator"},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW4.html","id":"q2-constructing-a-simulation-study","dir":"Articles","previous_headings":"","what":"Q2: Constructing a simulation study","title":"BIOST 561: Homework 4","text":"Intent: intent question construct simulation study ’ll run Bayes. question, ’ll designing simulation. Bayes couple reasons: 1) give experience running code Bayes, 2) simulations might take couple hours run. Note: inside file compute_maximal_partial_clique_master.R (now R folder), ’ve provided two functions: compute_maximal_partial_clique_master() compute_correct_density(). find functions useful Q2 Q3. Question 2A: Please run following code. run , something gone wrong UWBiost561 package. (instance, might generate_partial_clique() function work correctly located R package.) can see, compute_maximal_partial_clique_master() function: 1) takes number argument (allows control implementation compute_maximal_partial_clique ’re using) 2) sets timer (, 30 seconds) function terminates 30 seconds. Using provided code framework, use compute_maximal_partial_clique_master() setting time_limit function terminates prematurely, .e., time_limit set small number. (, , hypothetically, function required 40 seconds complete, set time_limit 30 seconds.) changing ’ number ’ argument, can use implementation compute_maximal_partial_clique prefer question. Note: question, want generate adjacency matrix n large (.e., value close 50), time_limit small (.e., just seconds). deliberately want cause timed_out status. Question 2B: Describe like simulation study sentences. Specifically, making simulation plan (see Lecture 8 details). plan answer following questions: generating random graphs analysis? qualities random graphs ? (can use generate_partial_clique() function, describe kind graph generate_partial_clique() makes.) answer plan use generate_partial_clique generate graphs 10 nodes, clique fraction density .9 varying random graphs across different “levels” analysis? (example, can vary n, clique_fraction, clique_edge_density, /alpha. simulation study can focus changing one two values.) answer wan compare “number wins” using 4 different levels alpha (.5,.6,.7, .8) different methods using simulation study? (question moot homework since ’ll using 15 implementations compute_maximal_partial_clique, please write thoroughness.) answer using 15 implementations compute_maximal_partial_clique hope learn simulation study? Alternatively, trends/patterns/results hoping see? answer implementations worse different levels alpha many trials intend run per “level”? answer want 13 trials per level much time estimate simulation study need maximum? See Note 2 . answer 3.7 hours hard requirements imposing simulation study : must use 15 implementations compute_maximal_partial_clique simulation study, method used every adjacency matrix generate. simulation study must least 2 different levels, least 2 trials level. choosing vary n (number nodes), largest n consider simulation study n=50. Please use compute_maximal_partial_clique_master() using 15 implementations (instead calling compute_maximal_partial_clique implementations directly). Additionally, please set time_limit larger 30 (.e., regardless large simulation study gets, please allow 1 minute implementation). 15 implementations, wouldn’t want just one trial take 15 minutes! simulation study take less 5 hours run completion single core (.e., parallelized). See Note 2 . ideas can test : often method get maximal partial clique (among 15 methods) number nodes n changes, alpha changes? can also try incorporating fast implementation (terms time) simulation study. Feel free post Canvas Discussions thoughts simulation study unsure simulation study. Note 1: choose vary n simulation study, value n 30 make simulation take long time finish. Note 2: use compute_maximal_partial_clique_master(), can time function time_limit number seconds (default, 30 seconds). Therefore, number problem instances solve , roughly speaking, (number levels) x (number methods) x (number trials per level), maximum time simulation need (number levels) x (number methods) x (number trials per level) x 30 seconds. Note 3: Please design straightforward complicated simulation study appropriate comfort coding. overwhelmed homework, can code simulation study takes minutes complete. (can use demo class rough skeleton simulation study. course, can design way perform simulation study well.) Note 4: simulation study, (course) need generate random adjacency matrices. can use generate_partial_clique() already created HW3, can also modify generate_partial_clique() better suit simulation study’s goals. Note 5: feel overwhelmed, can --less plan simulation study similar demo done class (Lecture 8). Specifically, inside hw4_implementations.zip, files hw4-demo_bayes_execute.R, hw4-demo_bayes_execute.slurm, `hw4-demo_bayes_plot.R effectively tell specific simulation study. Feel free use scripts closely want simulation study. (However, still need make simulation function follow guidelines still. still non-trivial work still need .) (writing question, coding question.) Question 2C: R folder, design function executes intended simulation plan. (purposely loose open-ended designing simulation regarding inputs outputs. contrast HW3, everything spelled explicitly, now giving task meaningfully designing inputs/outputs.) Note 1: want use compute_maximal_partial_clique_master() simulation. make life easier switching different implementations. main difficulties question : extract store results compute_maximal_partial_clique_master() decide meaningful outputs simulation function return (example, probably don’t need return adj_mat adjacency matrices )? highly depend simulation plan trying study! handle instances compute_maximal_partial_clique_master(): ) times , B) errors, C) outputs alleged clique_idx invalid doesn’t form partial clique edge density alpha larger. Note 2: aware – healthy skeptic using people’s code simulation. Just method claims found partial clique, verify indeed partial clique edge density larger alpha. might want use compute_correct_density() function provided compute_maximal_partial_clique_master.R. Note 3: asking make function perform simulation (instead just R script) since asking test simulation function Question 2D . Note 4: allow simulation function take input different levels simulation study number trials (parameters choosing). way, can easily “test” “simple” simulation study Question 2D . Note 5: (ideally) want set simulation trial level, generate one random adjacency matrix used 15 different implementations compute_maximal_partial_clique. gives “fair” comparison across 15 methods. also might want set random seed (via set.seed()) generating random adjacency matrix trial can easily reproduce results particular trial needed. Note 6: question hardest part HW4. Since question purposely open-ended, harder use ChatGPT help function. However, future coding experiences open-ended, practicing “coding ChatGPT” unstructured settings good. encourage work classmates question (, per syllabus rules, directly copy classmate’s code). (nothing report question. code R folder, R Markdown file.) Question 2D: Create (one) unit tests simulation function. unit test (like unit tests HW3) tests/testthat folder. also purposely vague many tests kind unit tests write. decide! , ’re unleash code perform (potentially long) simulation test, hope ’ve tested simulation code well enough good use time. Note: unit tests fast (.e., take minute run). means unit tests performing complete simulation study. , ’ll useless unit test takes hour figure unit test passed. However, want unit tests (take less minute) give confidence code work running complete simulation study (might take hour). (nothing report question. code tests/testthat folder, R Markdown file.) Question 2E: Similar HW3, please include screenshot output running devtools::check(). still UWBiost561 package passes checks unit tests. (guideline, one screenshot show first 20--lines devtools::check() results, second screenshot show last 20--lines results.) can use knitr::include_graphics() function include figures inside R Markdown file. intent question provide “evidence” devtools::check() went smoothly. need worry screenshots show specifically.","code":"library(UWBiost561) set.seed(10) data <- UWBiost561::generate_partial_clique(n = 10,                                              clique_fraction = 0.5,                                             clique_edge_density = 0.95)  set.seed(10) result1 <- UWBiost561::compute_maximal_partial_clique_master(   adj_mat = data$adj_mat,    alpha = 0.95,    number = 11,    time_limit = 30 ) result1  set.seed(10) result2 <- UWBiost561::compute_maximal_partial_clique11(   adj_mat = data$adj_mat,    alpha = 0.95 ) result2 # knitr::include_graphics(\"C:/Users/jrjor/Pictures/Screenshots/Screenshot 2025-06-05 212913.png\") # knitr::include_graphics(\"C:/Users/jrjor/Pictures/Screenshots/Screenshot 2025-06-05 212901.png\")"},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW4.html","id":"q3-performing-the-simulation-study","dir":"Articles","previous_headings":"","what":"Q3: Performing the simulation study","title":"BIOST 561: Homework 4","text":"Intent: intent question perform simulation study practice visualizing simulation results. Now ’ve written function perform simulation study, want write code perform actual simulation study. technically involve least 3 new files vignettes folder: one .R file perform simulation study, one accompanying .slurm script submit .R file Bayes, one .R file load simulation results visualize results. following questions guide three files. Question 3A: vignettes folder, make file called HW4_simulation_execute.R, R script : 1) loads UWBiost561 package, 2) executes simulation function inside UWBiost561 package. simulation “full” simulation study outlined Question 2B . (specific .R file might take couple hours finish, depending complex simulation study .) end HW4_simulation_execute.R save simulation results HW4_simulation.RData, .RData file. (example, argument save() function file = ~/HW4_simulation.RData. save results HW4_simulation.RData file home directory Bayes.) , make accompanying HW4_simulation_execute.slurm submits HW4_simulation_execute.R job Bayes. Please limit 10gb memory (.e., line HW4_simulation_execute.slurm read #SBATCH --mem-per-cpu=10gb). (simulation study require 10 Gigabytes memory. , likely practical simulation study.) (nothing report question. code vignettes folder, R Markdown file.) See Lectures 7 8 details . Question 3B: Now, install UWBiost561 package R. Lecture 8 https://docs.google.com/document/d/1369bf2WE7n2FzhFoqUv2rgWMZRurYfjHmGMUNHfOWBU/edit?usp=sharing give options install UWBiost561 package Bayes. (nothing report question.) Question 3C: Now, run simulation study. terminal, means 1) navigate UWBiost561/vignettes folder Bayes (might something like cd ~/UWBiost561/vignettes) 2) run command: sbatch HW4_simulation_execute.slurm. Note 1: question might cause pain since might know script working intended. (Additionally, suppose test simulation function thoroughly. case, HW4_simulation_execute.slurm script might crash, ’ll forced debug UWBiost561 package re-install , etc. ’s pain. Trust , want test simulation function thoroughly Question.) Note 2: parallelize simulation across multiple cores write batch SLURM script submit multiple jobs question. (Many likely working homework similar times, guarantee server can allow entire course students submit parallelized jobs simultaneously.) note make sense , don’t worry . (nothing report question. simply running HW4_simulation_execute.slurm file.) Question 3D: Finally, create file called HW4_simulation_plot.R vignettes folder. design script load saved results HW4_simulation.RData, visualize results, save plot vignettes folder. Name one plot HW4_simulation.png. (can save plot different file format, .png easiest one work .) complicated script ? depends results saved HW4_simulation.RData. example, saved clique size method trial level, might need compute average clique size across trials level script. plot? depends simulation plan intended study (wrote Question 2B). ’m leaving open-ended can practice determining best demonstrate results ’re trying study. Note 1: can run HW4_simulation_plot.R script interactively Bayes. need write .slurm script prefer (since entire HW4_simulation_plot.R script take minutes run. , ’re simply loading plotting results. shouldn’t fancy computation performed script, indeed, shouldn’t computing maximal partial cliques script). Note 2: Feel free consult https://r-graph-gallery.com/ get ideas meaningfully visualize results. (nothing report question. code vignettes folder, R Markdown file.) Question 3E: Now, Bayes, least four new files vignettes folder due Question 3A-3D: HW4_simulation_execute.R, HW4_simulation_execute.slurm, HW4_simulation_plot.R, HW4_simulation.png. (might many files, okay files needed.) Commit push files via Git (using command line Bayes) onto GitHub.com (via git push), pull files via Git onto local laptop. (can pull either command line via git pull RStudio GUI.) Finally, include plot R Markdown file. (’m put plot vignettes folder push/pull UWBiost561 package ’m assuming knit HW4.Rmd file locally laptop, need somehow get plot Bayes onto local laptop.)","code":"#knitr::include_graphics(\"C:/Users/jrjor/Documents/UW/BIOST561/UWBiost561/vignettes/HW4_simulation.png\")"},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW4.html","id":"q4-describing-your-final-project","dir":"Articles","previous_headings":"","what":"Q4: Describing your final project","title":"BIOST 561: Homework 4","text":"Intent: intent question make sure plan final project. release final project specifications (, involve making PkgDown website R package choosing scope) Canvas. released (latest) May 25th. Please write (one five sentences) thinking final project. answer hasn’t changed since HW3, can copy-paste answer HW3 question HW4. dont specific code currently, may use project possible.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/HW4.html","id":"q5-feedback-optional","dir":"Articles","previous_headings":"","what":"Q5: Feedback (Optional)","title":"BIOST 561: Homework 4","text":"“question” additional way students communicate instructors. include positive feedback topics enjoyed learning module, critiques course difficulty/pacing, questions/confusions course material. feedback can help shape course rest quarter future years. Please mindful polite providing feedback. may leave question blank.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/UWBiost561.html","id":"function-1-generate-partial-clique","dir":"Articles","previous_headings":"","what":"Function 1: generate partial clique","title":"Get started","text":"Generate random adjacency matrix dense partial clique","code":"library(UWBiost561) set.seed(10) n_ = 10 clique_fraction_ = .5 clique_edge_density_ = .9  output = generate_partial_clique(n_,clique_fraction_,clique_edge_density_) output$adj_mat ##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ##  [1,]    1    1    0    1    1    0    1    0    0     0 ##  [2,]    1    1    0    1    1    0    1    0    0     0 ##  [3,]    0    0    1    0    0    0    0    0    0     0 ##  [4,]    1    1    0    1    1    0    1    0    0     0 ##  [5,]    1    1    0    1    1    0    0    0    0     0 ##  [6,]    0    0    0    0    0    1    0    0    0     0 ##  [7,]    1    1    0    1    0    0    1    0    0     1 ##  [8,]    0    0    0    0    0    0    0    1    0     0 ##  [9,]    0    0    0    0    0    0    0    0    1     0 ## [10,]    0    0    0    0    0    0    1    0    0     1"},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/UWBiost561.html","id":"function-2-compute_maximal_partial_clique","dir":"Articles","previous_headings":"","what":"Function 2: compute_maximal_partial_clique","title":"Get started","text":"Compute maximal partial clique","code":"set.seed(10)  n_ = 10 clique_fraction_ = .5 clique_edge_density_ = .9  adj_mat_ = generate_partial_clique(n_,clique_fraction_,clique_edge_density_)$adj_mat alpha_ = .6  output2 = compute_maximal_partial_clique(adj_mat_, alpha_)  output2$clique_idx ## [1]  1  2  4  5  7 10"},{"path":"https://jrjordanrh.github.io/UWBiost561/articles/UWBiost561.html","id":"function-3-compute_maximal_partial_clique_master","dir":"Articles","previous_headings":"","what":"Function 3: compute_maximal_partial_clique_master","title":"Get started","text":"function runs implementation (dictated number) using inputs adj_mat alpha. example, compute_maximal_partial_clique_master(adj_mat, alpha, number = 5) executes compute_maximal_partial_clique5(adj_mat, alpha).","code":"set.seed(10)  n_ = 10 clique_fraction_ = .5 clique_edge_density_ = .9   adj_mat2 = generate_partial_clique(n_,clique_fraction_,clique_edge_density_)$adj_mat alpha2 = .6 number2 = 5  output3 = compute_maximal_partial_clique_master(adj_mat2, alpha2, number2) output3$clique_idx ## [1]  1  2  4  5  7 10"},{"path":"https://jrjordanrh.github.io/UWBiost561/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"First Last. Author, maintainer.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Last F (2025). UWBiost561: Package (One Line, Title Case). R package version 0.0.0.9000, https://jrjordanrh.github.io/UWBiost561/.","code":"@Manual{,   title = {UWBiost561: What the Package Does (One Line, Title Case)},   author = {First Last},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://jrjordanrh.github.io/UWBiost561/}, }"},{"path":"https://jrjordanrh.github.io/UWBiost561/index.html","id":"uwbiost561","dir":"","previous_headings":"","what":"What the Package Does (One Line, Title Case)","title":"What the Package Does (One Line, Title Case)","text":"R package clique functions BIOST561 URL GitHub (.e., source code) : https://github.com/jrjordanrh/UWBiost561 URL Pkgdown webpage : https://jrjordanrh.github.io/UWBiost561/","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compare_alpha.html","id":null,"dir":"Reference","previous_headings":"","what":"compare_alpha — compare_alpha","title":"compare_alpha — compare_alpha","text":"compare_alpha","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compare_alpha.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"compare_alpha — compare_alpha","text":"","code":"compare_alpha(alpha, trial)"},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compare_alpha.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"compare_alpha — compare_alpha","text":"alpha vector values alpha trial number trials","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compare_alpha.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"compare_alpha — compare_alpha","text":"dataset results know whether provided clique_idx forms valid partial clique.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_correct_density.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the correct density, given a set of nodes — compute_correct_density","title":"Compute the correct density, given a set of nodes — compute_correct_density","text":"define clique_idx length 1 density 1.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_correct_density.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the correct density, given a set of nodes — compute_correct_density","text":"","code":"compute_correct_density(adj_mat, clique_idx)"},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_correct_density.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the correct density, given a set of nodes — compute_correct_density","text":"adj_mat symmetric matrix values 0 1, 1's along diagonal, row- column-names, 5 50  rows/columns (inclusive). clique_idx numeric vector index numbers corresponding nodes (.e., values 1 nrow(adj_mat)) function deems maximum partial clique. vector duplicate elements, must positive integers, largest value exceed nrow(adj_mat)","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_correct_density.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the correct density, given a set of nodes — compute_correct_density","text":"numeric, density edges among adj_mat[clique_idx,clique_idx]","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute maximal partial clique — compute_maximal_partial_clique","title":"Compute maximal partial clique — compute_maximal_partial_clique","text":"Compute maximal partial clique","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute maximal partial clique — compute_maximal_partial_clique","text":"","code":"compute_maximal_partial_clique(adj_mat, alpha)"},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute maximal partial clique — compute_maximal_partial_clique","text":"adj_mat adj_mat Numeric matrix (n×n) 0/1’s, symmetric, 1’s diagonal, alpha Single numeric ∈ 0.5, 1, minimum required edge‐density.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute maximal partial clique — compute_maximal_partial_clique","text":"list clique_idx edge_density","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique1.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Maximal Partial Clique — compute_maximal_partial_clique1","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique1","text":"Compute Maximal Partial Clique","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique1","text":"","code":"compute_maximal_partial_clique1(adj_mat, alpha, verbose = FALSE)"},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique1","text":"adj_mat symmetric 0/1 adjacency matrix 1s diagonal. alpha numeric threshold 0.5 1 indicating required edge density. verbose Logical; whether print debug output. Default FALSE.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique1","text":"list : clique_idx Vector node indices maximal partial clique. edge_density Density subgraph induced clique_idx.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique10.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Maximal Partial Clique — compute_maximal_partial_clique10","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique10","text":"Given adjacency matrix edge density threshold alpha, function computes maximal partial clique — subset nodes whose induced subgraph edge density least alpha.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique10.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique10","text":"","code":"compute_maximal_partial_clique10(adj_mat, alpha)"},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique10.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique10","text":"adj_mat symmetric binary (0/1) matrix 1s diagonal, row/column names. Must 5 50 rows/columns. alpha single numeric value 0.5 1 (inclusive) specifying minimum required edge density.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique10.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique10","text":"list following elements: clique_idx, numeric vector node indices forming maximal partial clique. edge_density, edge density (0 1) returned clique.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique10.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique10","text":"","code":"adj <- matrix(1, nrow = 6, ncol = 6) adj[1, 2] <- adj[2, 1] <- 0 diag(adj) <- 1 result <- compute_maximal_partial_clique10(adj, 0.9) print(result) #> $clique_idx #> [1] 1 2 3 4 5 6 #>  #> $edge_density #> [1] 0.9333333 #>"},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique11.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute maximal partial clique — compute_maximal_partial_clique11","title":"Compute maximal partial clique — compute_maximal_partial_clique11","text":"Determines indices corresponding maximal partial clique adjacency matrix given partial clique density.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique11.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute maximal partial clique — compute_maximal_partial_clique11","text":"","code":"compute_maximal_partial_clique11(adj_mat, alpha, method = c(\"simple\", \"pivot\"))"},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique11.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute maximal partial clique — compute_maximal_partial_clique11","text":"adj_mat symmetric adjacency matrix 5-50 rows columns. alpha numeric value 0.5 1 (inclusive) indicating minimum fraction edges among nodes outputted partial clique. method One \"simple\" \"pivot\". \"simple\" searches maximal partial clique using modified version original Bron-Kerbosch algorithm, \"pivot\" uses modified version Bron-Kerbosch algorith pivot (Bron & Kerbosch 1973).","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique11.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute maximal partial clique — compute_maximal_partial_clique11","text":"Outputs list containing clique_idx: vector indices form partial clique edge_density: Percentage edges adj_mat among nodes clique_idx.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique11.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute maximal partial clique — compute_maximal_partial_clique11","text":"function uses modified versions Bron-Kerbosch algorithm, designed compute maximal full cliques, compute maximal partial cliques, allowing users specify \"simple\" \"pivot\" (Bron & Kerbosch 1973). Specifically, alpha < 1, algorithm modified candidate excluded nodes iteration restricted neighbors. Rather, candidate clique initially reported maximal clique satisfies density alpha/2 (help find cliques two nodes alone satisfy alpha density, together clique ), searches final results choose largest clique satisfies alpha. alpha = 1 set, Bron-Kerbosch algorithm applied directly. Using","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique11.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute maximal partial clique — compute_maximal_partial_clique11","text":"Bron, C., & Kerbosch, J. (1973). Algorithm 457: finding cliques undirected graph. Communications ACM, 16(9), 575-577.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique12.html","id":null,"dir":"Reference","previous_headings":"","what":"find maximal partial clique — compute_maximal_partial_clique12","title":"find maximal partial clique — compute_maximal_partial_clique12","text":"find maximal partial clique","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique12.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"find maximal partial clique — compute_maximal_partial_clique12","text":"","code":"compute_maximal_partial_clique12(adj_mat, alpha)"},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique12.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"find maximal partial clique — compute_maximal_partial_clique12","text":"adj_mat matrix look maximal partial clique alpha density partial clique needs reach","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique12.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"find maximal partial clique — compute_maximal_partial_clique12","text":"returns list two things, nodes maximal partial clique, density","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique13.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute maximal partial clique — compute_maximal_partial_clique13","title":"Compute maximal partial clique — compute_maximal_partial_clique13","text":"Compute maximal partial clique","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique13.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute maximal partial clique — compute_maximal_partial_clique13","text":"","code":"compute_maximal_partial_clique13(adj_mat, alpha)"},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique13.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute maximal partial clique — compute_maximal_partial_clique13","text":"adj_mat adj_mat Numeric matrix (n_n) 0/1's, symmetric, 1's diagonal, row/col names, 5:50. alpha Single numeric 0.5 1, minimum required edge-density.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique13.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute maximal partial clique — compute_maximal_partial_clique13","text":"list clique_idx edge_density","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique14.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute maximal partial clique function — compute_maximal_partial_clique14","title":"Compute maximal partial clique function — compute_maximal_partial_clique14","text":"function identifies subset nodes binary symmetric adjacency matrix form maximal partial clique edge density least alpha. uses greedy expansion algorithm starting top-k highest-degree nodes iteratively adds nodes maintaining required edge density. However, guarantee best solution every task, limited top-k, especially top-k large matrix size large.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique14.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute maximal partial clique function — compute_maximal_partial_clique14","text":"","code":"compute_maximal_partial_clique14(adj_mat, alpha, top_k_seeds = NULL)"},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique14.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute maximal partial clique function — compute_maximal_partial_clique14","text":"adj_mat nxn undirected graph 1 meaning connected 0 meaning unconnected. symmetric generated generate_partial_clique_function. n 5 50 inclusive. alpha threshold minimum edge density potential clique. range 0.5 1 inclusive. top_k_seeds value make algorithm efficient setting starter nodes connections. set sqrt number nodes matrix.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique14.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute maximal partial clique function — compute_maximal_partial_clique14","text":"list two elements: clique_idx numeric vector node indices partial clique. edge_density edge density among nodes.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique15.html","id":null,"dir":"Reference","previous_headings":"","what":"Find hte matximal partial clique — compute_maximal_partial_clique15","title":"Find hte matximal partial clique — compute_maximal_partial_clique15","text":"Start first entry, iteratively add nodes. first moment find valid click, stop","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique15.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find hte matximal partial clique — compute_maximal_partial_clique15","text":"","code":"compute_maximal_partial_clique15(adj_mat, alpha)"},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique15.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find hte matximal partial clique — compute_maximal_partial_clique15","text":"adj_mat graph alpha minimum threshold stop","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique15.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find hte matximal partial clique — compute_maximal_partial_clique15","text":"list","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique2.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute partial clique — compute_maximal_partial_clique2","title":"Compute partial clique — compute_maximal_partial_clique2","text":"Randomly try bunch cliques return largest one passes threshold","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute partial clique — compute_maximal_partial_clique2","text":"","code":"compute_maximal_partial_clique2(adj_mat, alpha)"},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute partial clique — compute_maximal_partial_clique2","text":"adj_mat adjacency matrix 0,1 alpha minimum edge density","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute partial clique — compute_maximal_partial_clique2","text":"list containing maximum partial clique density","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique3.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute maximum partial clique. — compute_maximal_partial_clique3","title":"Compute maximum partial clique. — compute_maximal_partial_clique3","text":"Compute maximum partial clique.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique3.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute maximum partial clique. — compute_maximal_partial_clique3","text":"","code":"compute_maximal_partial_clique3(adj_mat, alpha, verbose = 0)"},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique3.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute maximum partial clique. — compute_maximal_partial_clique3","text":"adj_mat Matrix. Adjacency matrix search. alpha Numeric. Minimum edge density potential partial clique. verbose boolean","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique3.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute maximum partial clique. — compute_maximal_partial_clique3","text":"List. clique_idx Nodes found maximum partial clique. edge_density Edge density found clique. alpha.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique4.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Maximal Partial Clique — compute_maximal_partial_clique4","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique4","text":"function computes approximate maximal partial clique given adjacency matrix, edge density among selected nodes least alpha.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique4.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique4","text":"","code":"compute_maximal_partial_clique4(adj_mat, alpha)"},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique4.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique4","text":"adj_mat symmetric adjacency matrix (0/1) diagonal 1s. alpha numeric value 0.5 1, representing minimum edge density required.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique4.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Maximal Partial Clique — compute_maximal_partial_clique4","text":"list following elements: clique_idx numeric vector node indices form partial clique. edge_density edge density among selected nodes (0 1).","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique5.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute a Maximal Partial Clique — compute_maximal_partial_clique5","title":"Compute a Maximal Partial Clique — compute_maximal_partial_clique5","text":"function attempts find largest subset nodes binary adjacency matrix induced subgraph edge density least alpha. approach uses greedy heuristic: node graph, iteratively adds neighboring nodes increase edge density additions satisfy required threshold. method guarantee global optimum, returns reasonably large dense partial clique within practical time frame.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique5.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute a Maximal Partial Clique — compute_maximal_partial_clique5","text":"","code":"compute_maximal_partial_clique5(adj_mat, alpha, verbose = FALSE)"},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique5.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute a Maximal Partial Clique — compute_maximal_partial_clique5","text":"adj_mat symmetric binary adjacency matrix 1s diagonal row/col names. alpha numeric scalar 0.5 1. Minimum required edge density. verbose Logical; TRUE, prints progress. Default FALSE.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique5.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute a Maximal Partial Clique — compute_maximal_partial_clique5","text":"list : clique_idx Numeric vector node indices forming partial clique. edge_density actual edge density among nodes.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique5.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute a Maximal Partial Clique — compute_maximal_partial_clique5","text":"final result includes indices selected nodes achieved edge density.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique6.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute maximal partial clique — compute_maximal_partial_clique6","title":"Compute maximal partial clique — compute_maximal_partial_clique6","text":"function finds reasonably large set nodes graph (represented adjacency matrix) forms partial clique edge density least alpha. uses greedy approach expand highly connected nodes.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique6.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute maximal partial clique — compute_maximal_partial_clique6","text":"","code":"compute_maximal_partial_clique6(adj_mat, alpha)"},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique6.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute maximal partial clique — compute_maximal_partial_clique6","text":"adj_mat symmetric binary adjacency matrix diagonal 1s row/column names. alpha numeric value 0.5 1. minimum density required clique.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique6.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute maximal partial clique — compute_maximal_partial_clique6","text":"list two elements: clique_idx Indices nodes maximal partial clique. edge_density edge density among selected nodes.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique7.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the maximal partial clique in an adjacency matrix — compute_maximal_partial_clique7","title":"Find the maximal partial clique in an adjacency matrix — compute_maximal_partial_clique7","text":"Find maximal partial clique adjacency matrix","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique7.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the maximal partial clique in an adjacency matrix — compute_maximal_partial_clique7","text":"","code":"compute_maximal_partial_clique7(adj_mat, alpha)"},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique7.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the maximal partial clique in an adjacency matrix — compute_maximal_partial_clique7","text":"adj_mat symmetric matrix 5 50 rows alpha numeric value 0.5 1","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique7.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the maximal partial clique in an adjacency matrix — compute_maximal_partial_clique7","text":"list containing clique_idx edge density","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique8.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute maximal partial clique This function computes the maximal partial clique by recursively removing the node with the least number of edges until the desired density (alpha) is obtained — compute_maximal_partial_clique8","title":"Compute maximal partial clique This function computes the maximal partial clique by recursively removing the node with the least number of edges until the desired density (alpha) is obtained — compute_maximal_partial_clique8","text":"Compute maximal partial clique function computes maximal partial clique recursively removing node least number edges desired density (alpha) obtained","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique8.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute maximal partial clique This function computes the maximal partial clique by recursively removing the node with the least number of edges until the desired density (alpha) is obtained — compute_maximal_partial_clique8","text":"","code":"compute_maximal_partial_clique8(adj_mat, alpha)"},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique8.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute maximal partial clique This function computes the maximal partial clique by recursively removing the node with the least number of edges until the desired density (alpha) is obtained — compute_maximal_partial_clique8","text":"adj_mat adjacency matrix edges node . contain least 5 nodes 50. alpha density required partial clique, excluding self-edges.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique8.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute maximal partial clique This function computes the maximal partial clique by recursively removing the node with the least number of edges until the desired density (alpha) is obtained — compute_maximal_partial_clique8","text":"list containing index clique clique_idx density clique","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique9.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the maximal partial clique — compute_maximal_partial_clique9","title":"Compute the maximal partial clique — compute_maximal_partial_clique9","text":"function finds subset nodes forming partial clique given adjacency matrix edge density among nodes least alpha.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique9.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the maximal partial clique — compute_maximal_partial_clique9","text":"","code":"compute_maximal_partial_clique9(adj_mat, alpha)"},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique9.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the maximal partial clique — compute_maximal_partial_clique9","text":"adj_mat symmetric 0/1 adjacency matrix diagonal values 1, row/column names, size 5 50. alpha single numeric value 0.5 1, specifying required minimum edge density.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique9.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the maximal partial clique — compute_maximal_partial_clique9","text":"list two elements: clique_idx numeric vector node indices forming identified partial clique. edge_density actual edge density among selected nodes.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique9.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute the maximal partial clique — compute_maximal_partial_clique9","text":"function uses simple greedy algorithm build candidate cliques returns largest one finds satisfies density threshold.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique_master.html","id":null,"dir":"Reference","previous_headings":"","what":"Master file for computing maximal partial clique — compute_maximal_partial_clique_master","title":"Master file for computing maximal partial clique — compute_maximal_partial_clique_master","text":"function runs implementation (dictated number) using inputs adj_mat alpha. example, compute_maximal_partial_clique_master(adj_mat, alpha, number = 5) executes compute_maximal_partial_clique5(adj_mat, alpha).","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique_master.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Master file for computing maximal partial clique — compute_maximal_partial_clique_master","text":"","code":"compute_maximal_partial_clique_master(adj_mat, alpha, number, time_limit = 30)"},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique_master.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Master file for computing maximal partial clique — compute_maximal_partial_clique_master","text":"adj_mat symmetric matrix values 0 1, 1's along diagonal, row- column-names, 5 50  rows/columns (inclusive) alpha single numeric (.e., length 1), value 0.5 1 (inclusive) number implementation number use time_limit number seconds implementation times ","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique_master.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Master file for computing maximal partial clique — compute_maximal_partial_clique_master","text":"list clique_idx, edge_density (implementation ) status valid (added function)","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/compute_maximal_partial_clique_master.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Master file for computing maximal partial clique — compute_maximal_partial_clique_master","text":"implementation errors (.e., crashes), output status error. implementation complete within time_limit number seconds (.e., took long), output status timed_out. valid output boolean whether provided clique_idx forms valid partial clique. method status timed_out error, method (default) valid=FALSE.","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/generate_partial_clique.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a random adjacency matrix with a dense partial clique — generate_partial_clique","title":"Generate a random adjacency matrix with a dense partial clique — generate_partial_clique","text":"Generate random adjacency matrix dense partial clique","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/generate_partial_clique.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a random adjacency matrix with a dense partial clique — generate_partial_clique","text":"","code":"generate_partial_clique(   n,   clique_fraction,   clique_edge_density,   outside_edge_density = 0.05,   seed = 500,   diag_one = TRUE )"},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/generate_partial_clique.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a random adjacency matrix with a dense partial clique — generate_partial_clique","text":"n Positive integer: number nodes (matrix dimension). clique_fraction Fraction nodes belonging clique (0–1). clique_edge_density Edge density within clique (0–1). outside_edge_density Edge probability every non‑clique pair (including clique–non‑clique pairs). Default 0.05. seed fixes seed.  Default 500 diag_one Logical; TRUE (default) place 1’s diagonal, otherwise leave 0’s (strict graph‑theory convention).","code":""},{"path":"https://jrjordanrh.github.io/UWBiost561/reference/generate_partial_clique.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a random adjacency matrix with a dense partial clique — generate_partial_clique","text":"List five elements: adj_mat Original n × n symmetric 0/1 matrix. adj_mat_ordered matrix permuted clique block upper‑left. node_order Permutation putting clique nodes first. clique_nodes Indices (original ordering) clique nodes. edge_target # edges required inside clique.","code":""}]
